# Security Vulnerability Assessment Guide

## Overview
Comprehensive guide for conducting security vulnerability assessments in the MealPrep application, covering automated scanning, manual testing, penetration testing, and continuous security monitoring practices.

## Vulnerability Assessment Strategy

### Security Assessment Philosophy
- **Defense in Depth**: Multi-layered security approach across all application tiers
- **Continuous Assessment**: Regular and automated security testing throughout development
- **Risk-Based Approach**: Prioritize vulnerabilities based on business impact and exploitability
- **Zero Trust**: Assume breach and verify everything
- **Proactive Security**: Identify and remediate vulnerabilities before they're exploited

### Assessment Types
1. **Automated Vulnerability Scanning**: SAST, DAST, dependency scanning
2. **Manual Security Testing**: Code review, configuration assessment
3. **Penetration Testing**: Simulated attacks on applications and infrastructure
4. **Threat Modeling**: Systematic analysis of potential threats
5. **Compliance Assessment**: Regulatory and standard compliance validation

### Security Standards and Frameworks
- **OWASP Top 10**: Web application security risks
- **NIST Cybersecurity Framework**: Comprehensive security guidelines
- **ISO 27001**: Information security management
- **GDPR**: Data protection compliance
- **SOC 2**: Security controls for service organizations

---

## Automated Vulnerability Scanning

### Static Application Security Testing (SAST)

#### SonarQube Integration
```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  sast-scan:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Full history for SonarQube
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'
    
    - name: Setup SonarQube Scanner
      uses: sonarsource/sonarqube-github-action@master
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      with:
        args: >
          -Dsonar.projectKey=mealprep
          -Dsonar.sources=src/
          -Dsonar.tests=tests/
          -Dsonar.cs.opencover.reportsPaths=**/coverage.opencover.xml
          -Dsonar.cs.vstest.reportsPaths=**/*.trx
          -Dsonar.security.enable=true
          -Dsonar.security.hotspots=true
    
    - name: Run Security-focused Tests
      run: |
        dotnet test --logger trx --collect:"XPlat Code Coverage" \
          --results-directory coverage -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover
```

#### CodeQL Security Analysis
```yaml
# .github/workflows/codeql-analysis.yml
name: CodeQL Security Analysis

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 6 * * 1'  # Weekly on Monday

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: ['csharp', 'javascript']

    steps:
    - uses: actions/checkout@v3

    - name: Initialize CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: ${{ matrix.language }}
        queries: +security-and-quality
        
    - name: Autobuild
      uses: github/codeql-action/autobuild@v2

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2
      with:
        category: "/language:${{matrix.language}}"
```

### Dynamic Application Security Testing (DAST)

#### OWASP ZAP Integration
```yaml
# .github/workflows/dast-scan.yml
name: DAST Security Scan

on:
  push:
    branches: [main]
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM

jobs:
  dast-scan:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Build and Start Application
      run: |
        docker-compose -f docker-compose.test.yml up -d
        sleep 60  # Wait for application to start
    
    - name: ZAP Baseline Scan
      uses: zaproxy/action-baseline@v0.7.0
      with:
        target: 'http://localhost:5000'
        rules_file_name: 'zap-rules.tsv'
        cmd_options: '-a -j -m 10 -T 60'
        
    - name: ZAP Full Scan
      uses: zaproxy/action-full-scan@v0.4.0
      with:
        target: 'http://localhost:5000'
        rules_file_name: 'zap-rules.tsv'
        cmd_options: '-a -j -m 10 -T 120'
        
    - name: Upload ZAP Reports
      uses: actions/upload-artifact@v3
      with:
        name: zap-reports
        path: |
          report_html.html
          report_json.json
```

#### ZAP Rules Configuration
```tsv
# zap-rules.tsv
10003	IGNORE	# Suspicious comments (false positives in documentation)
10096	IGNORE	# Timestamp disclosure (acceptable for API responses)
10038	IGNORE	# Content-Type header missing (handled by middleware)
40018	WARN	# SQL Injection (requires manual verification)
40019	WARN	# SQL Injection (Oracle) (not applicable - using SQL Server)
40020	WARN	# SQL Injection (MySQL) (not applicable)
40021	WARN	# SQL Injection (PostgreSQL) (not applicable)
90019	FAIL	# Server Side Code Injection (critical security issue)
90020	FAIL	# Remote OS Command Injection (critical security issue)
```

### Dependency Vulnerability Scanning

#### npm audit for Frontend Dependencies
```bash
#!/bin/bash
# scripts/security/frontend-dependency-scan.sh

echo "Running npm security audit..."

# Run npm audit
npm audit --audit-level moderate --production

# Generate detailed audit report
npm audit --json > reports/npm-audit-report.json

# Check for high/critical vulnerabilities
CRITICAL=$(npm audit --json | jq '.metadata.vulnerabilities.critical // 0')
HIGH=$(npm audit --json | jq '.metadata.vulnerabilities.high // 0')

echo "Critical vulnerabilities: $CRITICAL"
echo "High vulnerabilities: $HIGH"

if [ "$CRITICAL" -gt 0 ] || [ "$HIGH" -gt 5 ]; then
    echo "Security scan failed: Too many high/critical vulnerabilities"
    exit 1
fi

echo "Frontend dependency security scan passed"
```

#### .NET Dependency Scanning with Snyk
```yaml
# .github/workflows/dependency-scan.yml
name: Dependency Security Scan

on:
  push:
    branches: [main, develop]
  schedule:
    - cron: '0 3 * * 1'  # Weekly on Monday

jobs:
  dependency-scan:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore NuGet packages
      run: dotnet restore
    
    - name: Run Snyk to check for vulnerabilities
      uses: snyk/actions/dotnet@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=high --file=MealPrep.sln
        
    - name: Upload Snyk results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: snyk.sarif
```

---

## Manual Security Testing

### Code Review Security Checklist

#### Backend Security Review (.NET/C#)
```csharp
// Security Code Review Checklist for C# Backend

// 1. INPUT VALIDATION
public class RecipeController : ControllerBase
{
    [HttpPost]
    public async Task<IActionResult> CreateRecipe([FromBody] CreateRecipeDto request)
    {
        // ? Input validation with data annotations
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        
        // ? Additional business logic validation
        if (request.PrepTimeMinutes < 0 || request.PrepTimeMinutes > 1440)
            return BadRequest("Invalid preparation time");
        
        // ? SQL injection prevention using parameterized queries
        var recipe = await _recipeService.CreateAsync(request);
        return Ok(recipe);
    }
}

// 2. AUTHENTICATION AND AUTHORIZATION
[Authorize] // ? Require authentication
[RequiredScope("recipes.write")] // ? Specific permissions
public class RecipeController : ControllerBase
{
    private readonly ICurrentUserService _currentUser;
    
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteRecipe(int id)
    {
        // ? Authorization check - users can only delete their own recipes
        var recipe = await _recipeRepository.GetByIdAsync(id);
        if (recipe.CreatedByUserId != _currentUser.UserId)
            return Forbid();
        
        await _recipeService.DeleteAsync(id);
        return NoContent();
    }
}

// 3. DATA PROTECTION
public class UserService
{
    private readonly IDataProtectionProvider _dataProtection;
    
    public async Task<User> CreateUserAsync(CreateUserDto request)
    {
        // ? Password hashing (never store plain text)
        var passwordHash = BCrypt.Net.BCrypt.HashPassword(request.Password, 12);
        
        // ? Sensitive data encryption
        var protector = _dataProtection.CreateProtector("UserData.v1");
        var encryptedHealthGoals = protector.Protect(request.HealthGoals);
        
        var user = new User
        {
            Email = request.Email,
            PasswordHash = passwordHash,
            EncryptedHealthGoals = encryptedHealthGoals
        };
        
        return await _userRepository.CreateAsync(user);
    }
}

// 4. LOGGING AND MONITORING (avoid logging sensitive data)
public class AuthenticationService
{
    private readonly ILogger<AuthenticationService> _logger;
    
    public async Task<LoginResult> LoginAsync(LoginRequest request)
    {
        // ? Log security events without sensitive data
        _logger.LogInformation("Login attempt for user {Email}", request.Email);
        
        var user = await _userRepository.GetByEmailAsync(request.Email);
        if (user == null || !BCrypt.Net.BCrypt.Verify(request.Password, user.PasswordHash))
        {
            // ? Log failed attempts for security monitoring
            _logger.LogWarning("Failed login attempt for {Email} from {IpAddress}", 
                request.Email, GetClientIpAddress());
            
            return LoginResult.Failed();
        }
        
        _logger.LogInformation("Successful login for user {UserId}", user.Id);
        return LoginResult.Success(user);
    }
}
```

#### Frontend Security Review (React/TypeScript)
```typescript
// Security Code Review Checklist for React Frontend

// 1. XSS PREVENTION
const RecipeCard: React.FC<{ recipe: Recipe }> = ({ recipe }) => {
  return (
    <div className="recipe-card">
      {/* ? React automatically escapes content */}
      <h3>{recipe.name}</h3>
      
      {/* ? Sanitize HTML content from external sources */}
      <div 
        dangerouslySetInnerHTML={{
          __html: DOMPurify.sanitize(recipe.description)
        }}
      />
      
      {/* ? NEVER do this - vulnerable to XSS */}
      {/* <div dangerouslySetInnerHTML={{ __html: recipe.userContent }} /> */}
    </div>
  );
};

// 2. SECURE API CALLS
class ApiClient {
  private baseUrl: string;
  private authToken: string | null = null;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  async makeRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    // ? Always use HTTPS in production
    const url = `${this.baseUrl}${endpoint}`;
    
    // ? Include authentication token
    const headers = {
      'Content-Type': 'application/json',
      ...options.headers,
    };
    
    if (this.authToken) {
      headers['Authorization'] = `Bearer ${this.authToken}`;
    }
    
    // ? Validate response and handle errors securely
    const response = await fetch(url, { ...options, headers });
    
    if (!response.ok) {
      // ? Don't expose sensitive error information
      throw new Error(`Request failed: ${response.status}`);
    }
    
    return response.json();
  }
}

// 3. SECURE TOKEN STORAGE
class AuthService {
  private static readonly TOKEN_KEY = 'mealprep_auth_token';
  
  // ? Use secure storage (consider httpOnly cookies for production)
  setToken(token: string): void {
    // For demo purposes - in production, use httpOnly cookies
    sessionStorage.setItem(AuthService.TOKEN_KEY, token);
  }
  
  getToken(): string | null {
    return sessionStorage.getItem(AuthService.TOKEN_KEY);
  }
  
  // ? Proper logout - clear all stored data
  logout(): void {
    sessionStorage.removeItem(AuthService.TOKEN_KEY);
    // Clear any other sensitive data from storage
    localStorage.removeItem('user_preferences');
  }
}

// 4. INPUT SANITIZATION
const SearchForm: React.FC = () => {
  const [searchTerm, setSearchTerm] = useState('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // ? Validate and sanitize input
    const sanitizedTerm = searchTerm.trim().slice(0, 100); // Limit length
    
    if (sanitizedTerm.length < 2) {
      setError('Search term must be at least 2 characters');
      return;
    }
    
    // ? Encode for URL
    const encodedTerm = encodeURIComponent(sanitizedTerm);
    performSearch(encodedTerm);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        maxLength={100} // ? Client-side length limit
        placeholder="Search recipes..."
      />
      <button type="submit">Search</button>
    </form>
  );
};
```

### Infrastructure Security Assessment

#### Docker Security Checklist
```dockerfile
# Dockerfile security best practices
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base

# ? Use non-root user
RUN groupadd -r mealprep && useradd -r -g mealprep mealprep
USER mealprep

WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# ? Copy only necessary files
COPY ["MealPrep.Api/MealPrep.Api.csproj", "MealPrep.Api/"]
COPY ["MealPrep.Core/MealPrep.Core.csproj", "MealPrep.Core/"]
RUN dotnet restore "MealPrep.Api/MealPrep.Api.csproj"

COPY . .
WORKDIR "/src/MealPrep.Api"
RUN dotnet build "MealPrep.Api.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "MealPrep.Api.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app

# ? Change ownership to non-root user
COPY --from=publish --chown=mealprep:mealprep /app/publish .

# ? Run as non-root user
USER mealprep

ENTRYPOINT ["dotnet", "MealPrep.Api.dll"]
```

#### Kubernetes Security Configuration
```yaml
# k8s/security-policies.yaml
apiVersion: v1
kind: SecurityContext
metadata:
  name: mealprep-security-context
spec:
  # ? Run as non-root
  runAsNonRoot: true
  runAsUser: 1001
  runAsGroup: 1001
  
  # ? Read-only root filesystem
  readOnlyRootFilesystem: true
  
  # ? Drop all capabilities
  capabilities:
    drop:
      - ALL
  
  # ? Disable privilege escalation
  allowPrivilegeEscalation: false

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: mealprep-network-policy
spec:
  podSelector:
    matchLabels:
      app: mealprep
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: nginx-ingress
    ports:
    - protocol: TCP
      port: 80
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
```

---

## Penetration Testing

### Automated Penetration Testing

#### OWASP ZAP Automated Tests
```python
#!/usr/bin/env python3
# scripts/security/automated-pentest.py

import time
import json
from zapv2 import ZAPv2

class MealPrepPenTest:
    def __init__(self, target_url='http://localhost:5000'):
        self.target_url = target_url
        self.zap = ZAPv2(proxies={'http': 'http://127.0.0.1:8080', 
                                 'https': 'http://127.0.0.1:8080'})
        
    def setup_authentication(self):
        """Configure authentication for authenticated scanning"""
        # Set up authentication script
        auth_script = '''
        function authenticate(helper, paramsValues, credentials) {
            var loginUrl = "%s/auth/login";
            var postData = "email=" + credentials.getParam("email") + 
                          "&password=" + credentials.getParam("password");
            
            var msg = helper.prepareMessage();
            msg.setRequestHeader("Content-Type: application/json");
            msg.setRequestBody(JSON.stringify({
                email: credentials.getParam("email"),
                password: credentials.getParam("password")
            }));
            msg.getRequestHeader().setURI(new URI(loginUrl, false));
            msg.getRequestHeader().setMethod("POST");
            
            helper.sendAndReceive(msg);
            
            return msg;
        }
        
        function getRequiredParamsNames() {
            return ["email", "password"];
        }
        
        function getOptionalParamsNames() {
            return [];
        }
        
        function getCredentialsParamsNames() {
            return ["email", "password"];
        }
        ''' % self.target_url
        
        # Configure authentication
        self.zap.authentication.set_authentication_method(
            contextid=0,
            authmethodname='scriptBasedAuthentication',
            authmethodconfigparams='scriptName=MealPrepAuth&scriptEngine=Oracle Nashorn'
        )
        
    def run_spider_scan(self):
        """Run spider scan to discover URLs"""
        print("Starting spider scan...")
        
        # Start spider
        scan_id = self.zap.spider.scan(self.target_url)
        
        # Wait for spider to complete
        while int(self.zap.spider.status(scan_id)) < 100:
            print(f"Spider progress: {self.zap.spider.status(scan_id)}%")
            time.sleep(2)
            
        print("Spider scan completed")
        return self.zap.spider.results(scan_id)
        
    def run_active_scan(self):
        """Run active security scan"""
        print("Starting active scan...")
        
        # Start active scan
        scan_id = self.zap.ascan.scan(self.target_url)
        
        # Wait for scan to complete
        while int(self.zap.ascan.status(scan_id)) < 100:
            print(f"Active scan progress: {self.zap.ascan.status(scan_id)}%")
            time.sleep(5)
            
        print("Active scan completed")
        
    def generate_report(self):
        """Generate security test report"""
        print("Generating security report...")
        
        # Get alerts
        alerts = self.zap.core.alerts()
        
        # Categorize by risk level
        high_risk = [alert for alert in alerts if alert['risk'] == 'High']
        medium_risk = [alert for alert in alerts if alert['risk'] == 'Medium']
        low_risk = [alert for alert in alerts if alert['risk'] == 'Low']
        
        report = {
            'summary': {
                'total_alerts': len(alerts),
                'high_risk': len(high_risk),
                'medium_risk': len(medium_risk),
                'low_risk': len(low_risk)
            },
            'high_risk_vulnerabilities': high_risk,
            'medium_risk_vulnerabilities': medium_risk,
            'scan_timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        
        # Save report
        with open('reports/security-scan-report.json', 'w') as f:
            json.dump(report, f, indent=2)
            
        # Check if scan passed security thresholds
        if len(high_risk) > 0:
            print(f"? Security scan FAILED: {len(high_risk)} high-risk vulnerabilities found")
            return False
        elif len(medium_risk) > 5:
            print(f"?? Security scan WARNING: {len(medium_risk)} medium-risk vulnerabilities found")
            return False
        else:
            print("? Security scan PASSED")
            return True
            
    def run_full_scan(self):
        """Run complete penetration test"""
        print("Starting MealPrep security assessment...")
        
        try:
            # 1. Setup authentication
            self.setup_authentication()
            
            # 2. Discovery phase
            self.run_spider_scan()
            
            # 3. Vulnerability scanning
            self.run_active_scan()
            
            # 4. Generate report
            return self.generate_report()
            
        except Exception as e:
            print(f"Error during security scan: {e}")
            return False

if __name__ == "__main__":
    import sys
    
    target = sys.argv[1] if len(sys.argv) > 1 else 'http://localhost:5000'
    
    pentest = MealPrepPenTest(target)
    success = pentest.run_full_scan()
    
    sys.exit(0 if success else 1)
```

### Manual Penetration Testing Procedures

#### Authentication and Session Management Testing
```bash
#!/bin/bash
# scripts/security/manual-auth-tests.sh

API_BASE="http://localhost:5000/api"

echo "=== Authentication Security Tests ==="

# Test 1: Password strength requirements
echo "Testing password strength requirements..."
curl -X POST "$API_BASE/auth/register" \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"123","firstName":"Test","lastName":"User"}' \
  -w "HTTP %{http_code}\n"

# Test 2: SQL injection in login
echo "Testing SQL injection in login..."
curl -X POST "$API_BASE/auth/login" \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@example.com'\'' OR 1=1 --","password":"password"}' \
  -w "HTTP %{http_code}\n"

# Test 3: Brute force protection
echo "Testing brute force protection..."
for i in {1..10}; do
  curl -X POST "$API_BASE/auth/login" \
    -H "Content-Type: application/json" \
    -d '{"email":"admin@example.com","password":"wrongpassword'$i'"}' \
    -w "Attempt $i: HTTP %{http_code}\n"
  sleep 1
done

# Test 4: JWT token validation
echo "Testing JWT token validation..."
curl -X GET "$API_BASE/recipes" \
  -H "Authorization: Bearer invalid.jwt.token" \
  -w "HTTP %{http_code}\n"

# Test 5: Session timeout
echo "Testing session timeout (using expired token)..."
EXPIRED_TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9.invalidsignature"
curl -X GET "$API_BASE/recipes" \
  -H "Authorization: Bearer $EXPIRED_TOKEN" \
  -w "HTTP %{http_code}\n"
```

#### Input Validation Testing
```bash
#!/bin/bash
# scripts/security/input-validation-tests.sh

API_BASE="http://localhost:5000/api"
TOKEN="your_valid_jwt_token_here"

echo "=== Input Validation Security Tests ==="

# Test 1: XSS in recipe creation
echo "Testing XSS in recipe creation..."
curl -X POST "$API_BASE/recipes" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"<script>alert(\"XSS\")</script>","description":"Test recipe","instructions":"Cook it"}' \
  -w "HTTP %{http_code}\n"

# Test 2: SQL injection in search
echo "Testing SQL injection in search..."
curl -X GET "$API_BASE/recipes/search?searchTerm=test'\'' UNION SELECT * FROM Users --" \
  -H "Authorization: Bearer $TOKEN" \
  -w "HTTP %{http_code}\n"

# Test 3: Command injection in recipe instructions
echo "Testing command injection..."
curl -X POST "$API_BASE/recipes" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","description":"Test","instructions":"Step 1: Cook; rm -rf /"}' \
  -w "HTTP %{http_code}\n"

# Test 4: Path traversal in file upload (if implemented)
echo "Testing path traversal..."
curl -X POST "$API_BASE/recipes/1/image" \
  -H "Authorization: Bearer $TOKEN" \
  -F "file=@../../../etc/passwd" \
  -w "HTTP %{http_code}\n"

# Test 5: Large payload DoS
echo "Testing large payload handling..."
LARGE_PAYLOAD=$(python3 -c "print('A' * 10000)")
curl -X POST "$API_BASE/recipes" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","description":"'$LARGE_PAYLOAD'","instructions":"Cook"}' \
  -w "HTTP %{http_code}\n"
```

---

## Continuous Security Monitoring

### Security Metrics Dashboard
```typescript
// scripts/security/security-metrics.ts
interface SecurityMetrics {
  vulnerabilityCount: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  lastScanDate: string;
  complianceScore: number;
  incidentCount: number;
  patchingStatus: {
    upToDate: number;
    outdated: number;
    critical: number;
  };
}

export class SecurityMonitor {
  private metricsCollectionInterval: number = 24 * 60 * 60 * 1000; // 24 hours
  
  async collectSecurityMetrics(): Promise<SecurityMetrics> {
    const vulnerabilities = await this.getVulnerabilityCount();
    const compliance = await this.calculateComplianceScore();
    const incidents = await this.getIncidentCount();
    const patching = await this.getPatchingStatus();
    
    return {
      vulnerabilityCount: vulnerabilities,
      lastScanDate: new Date().toISOString(),
      complianceScore: compliance,
      incidentCount: incidents,
      patchingStatus: patching
    };
  }
  
  private async getVulnerabilityCount() {
    // Aggregate from various security tools
    const sonarQubeVulns = await this.fetchSonarQubeVulnerabilities();
    const snykVulns = await this.fetchSnykVulnerabilities();
    const zapVulns = await this.fetchZapVulnerabilities();
    
    return {
      critical: sonarQubeVulns.critical + snykVulns.critical + zapVulns.critical,
      high: sonarQubeVulns.high + snykVulns.high + zapVulns.high,
      medium: sonarQubeVulns.medium + snykVulns.medium + zapVulns.medium,
      low: sonarQubeVulns.low + snykVulns.low + zapVulns.low
    };
  }
  
  private async calculateComplianceScore(): Promise<number> {
    const checks = [
      await this.checkDataEncryption(),
      await this.checkAccessControls(),
      await this.checkAuditLogging(),
      await this.checkIncidentResponse(),
      await this.checkVulnerabilityManagement()
    ];
    
    const passedChecks = checks.filter(check => check).length;
    return (passedChecks / checks.length) * 100;
  }
  
  async generateSecurityReport(): Promise<void> {
    const metrics = await this.collectSecurityMetrics();
    
    const report = {
      generated: new Date().toISOString(),
      summary: {
        overallRisk: this.calculateOverallRisk(metrics),
        complianceStatus: metrics.complianceScore >= 80 ? 'COMPLIANT' : 'NON_COMPLIANT',
        criticalIssues: metrics.vulnerabilityCount.critical
      },
      metrics,
      recommendations: this.generateRecommendations(metrics)
    };
    
    // Save report and send alerts if needed
    await this.saveReport(report);
    
    if (report.summary.criticalIssues > 0) {
      await this.sendCriticalAlert(report);
    }
  }
  
  private calculateOverallRisk(metrics: SecurityMetrics): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
    if (metrics.vulnerabilityCount.critical > 0) return 'CRITICAL';
    if (metrics.vulnerabilityCount.high > 5) return 'HIGH';
    if (metrics.vulnerabilityCount.medium > 10) return 'MEDIUM';
    return 'LOW';
  }
  
  private generateRecommendations(metrics: SecurityMetrics): string[] {
    const recommendations: string[] = [];
    
    if (metrics.vulnerabilityCount.critical > 0) {
      recommendations.push('URGENT: Address critical vulnerabilities immediately');
    }
    
    if (metrics.complianceScore < 80) {
      recommendations.push('Improve compliance controls to reach 80% threshold');
    }
    
    if (metrics.patchingStatus.critical > 0) {
      recommendations.push('Install critical security patches');
    }
    
    return recommendations;
  }
}
```

### Automated Incident Response
```csharp
// Security incident detection and response
public class SecurityIncidentHandler
{
    private readonly ILogger<SecurityIncidentHandler> _logger;
    private readonly INotificationService _notifications;
    private readonly ISecurityService _security;

    public async Task HandleSecurityEvent(SecurityEvent securityEvent)
    {
        var incident = await EvaluateSecurityEvent(securityEvent);
        
        if (incident.Severity >= IncidentSeverity.High)
        {
            await InitiateIncidentResponse(incident);
        }
        
        await LogSecurityIncident(incident);
    }

    private async Task<SecurityIncident> EvaluateSecurityEvent(SecurityEvent evt)
    {
        var severity = CalculateSeverity(evt);
        var riskScore = await CalculateRiskScore(evt);
        
        return new SecurityIncident
        {
            Id = Guid.NewGuid(),
            EventType = evt.Type,
            Severity = severity,
            RiskScore = riskScore,
            SourceIp = evt.SourceIpAddress,
            UserId = evt.UserId,
            Timestamp = evt.Timestamp,
            Details = evt.Details
        };
    }

    private async Task InitiateIncidentResponse(SecurityIncident incident)
    {
        // 1. Immediate containment
        if (incident.Severity == IncidentSeverity.Critical)
        {
            await _security.BlockIpAddressAsync(incident.SourceIp);
            await _security.SuspendUserAccountAsync(incident.UserId);
        }

        // 2. Alert security team
        await _notifications.SendSecurityAlertAsync(new SecurityAlert
        {
            Severity = incident.Severity,
            Message = $"Security incident detected: {incident.EventType}",
            Details = incident.Details,
            RequiredAction = GetRequiredAction(incident)
        });

        // 3. Start investigation workflow
        await StartInvestigationWorkflow(incident);
    }

    private IncidentSeverity CalculateSeverity(SecurityEvent evt)
    {
        return evt.Type switch
        {
            SecurityEventType.MultipleFailedLogins => IncidentSeverity.Medium,
            SecurityEventType.SqlInjectionAttempt => IncidentSeverity.High,
            SecurityEventType.UnauthorizedDataAccess => IncidentSeverity.Critical,
            SecurityEventType.MaliciousFileUpload => IncidentSeverity.High,
            SecurityEventType.SuspiciousApiUsage => IncidentSeverity.Medium,
            _ => IncidentSeverity.Low
        };
    }
}
```

---

## Vulnerability Assessment Reporting

### Executive Security Summary
```markdown
# Security Assessment Executive Summary

## Overall Security Posture: [GREEN/YELLOW/RED]

### Key Metrics
- **Vulnerability Score**: 8.2/10 (Good)
- **Compliance Score**: 92% (Excellent)
- **Mean Time to Remediation**: 3.2 days
- **Security Test Coverage**: 87%

### Critical Findings
1. **High Priority**: SQL injection vulnerability in recipe search endpoint
   - **Risk**: High
   - **Impact**: Data breach potential
   - **Remediation**: Implement parameterized queries (2 days)

2. **Medium Priority**: Missing rate limiting on authentication endpoint
   - **Risk**: Medium
   - **Impact**: Brute force attacks
   - **Remediation**: Implement rate limiting (1 day)

### Compliance Status
- ? GDPR: Compliant
- ? SOC 2: Compliant
- ?? OWASP Top 10: 9/10 controls implemented
- ? ISO 27001: Compliant

### Recommendations
1. Address critical SQL injection vulnerability immediately
2. Implement comprehensive security training for development team
3. Enhance automated security testing in CI/CD pipeline
4. Conduct quarterly penetration testing
```

---

*Last Updated: December 2024*  
*Vulnerability assessment guide continuously updated with new security threats and testing methodologies*